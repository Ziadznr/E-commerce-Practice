/**
 * 主要思想和代码的某些部分（例如绘制可变宽度贝塞尔曲线）
 * http://corner.squareup.com/2012/07/smoother-signatures.html
 *
 * 使用三次贝塞尔曲线实现插值
 *
 * 贝塞尔曲线近似长度的算法
 * http://www.lemoda.net/maths/bezier-length/index.html
 */
import { Bezier } from './bezier';
import { Point } from './point';
import { SignatureEventTarget } from './event';
import { throttle } from './throttle';
export default class Signature extends SignatureEventTarget {
    canvas;
    dotSize;
    minWidth;
    maxWidth;
    penColor;
    minDistance;
    velocityFilterWeight;
    backgroundColor;
    throttle;
    _ctx;
    _drawningStroke;
    _isEmpty;
    _lastPoints; // 最多存储 4 个最近的点； 用于生成新曲线
    _data; // 以组的形式存储所有点（每条线或点一组）
    _lastVelocity;
    _lastWidth;
    _strokeMoveUpdate;
    constructor(canvas, options = {}) {
        super();
        this.canvas = canvas;
        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
        this.minWidth = options.minWidth || 0.5;
        this.maxWidth = options.maxWidth || 2.5;
        this.throttle = options.throttle || 16; // 以毫秒为单位
        this.minDistance = options.minDistance || 5; // 以像素为单位
        this.dotSize = options.dotSize || 0;
        this.penColor = options.penColor || 'black';
        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';
        this._strokeMoveUpdate = this.throttle
            ? throttle(Signature.prototype._strokeUpdate, this.throttle)
            : Signature.prototype._strokeUpdate;
        this._ctx = canvas.getContext('2d');
        // 启用鼠标和触摸事件处理程序
        this.on();
    }
    clear() {
        const { _ctx: ctx, canvas } = this;
        // 使用背景颜色清除画布
        ctx.fillStyle = this.backgroundColor;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._data = [];
        this._reset();
        this._isEmpty = true;
    }
    undo() {
        if (this._data) {
            this._data.pop(); // 删除最后一个点或线
            this.fromData(this._data);
        }
    }
    fromDataURL(dataUrl, options = {}) {
        return new Promise((resolve, reject) => {
            const image = new Image();
            const ratio = options.ratio || window.devicePixelRatio || 1;
            const width = options.width || this.canvas.width / ratio;
            const height = options.height || this.canvas.height / ratio;
            const xOffset = options.xOffset || 0;
            const yOffset = options.yOffset || 0;
            this._reset();
            image.onload = () => {
                this._ctx.drawImage(image, xOffset, yOffset, width, height);
                resolve();
            };
            image.onerror = (error) => {
                reject(error);
            };
            image.crossOrigin = 'anonymous';
            image.src = dataUrl;
            this._isEmpty = false;
        });
    }
    toDataURL(type = 'image/png', quality) {
        switch (type) {
            case 'image/svg+xml':
                return this._toSVG();
            default:
                return this.canvas.toDataURL(type, quality);
        }
    }
    on() {
        // 触摸画布元素时禁用平移/缩放
        this.canvas.style.touchAction = 'none';
        this.canvas.style.msTouchAction = 'none';
        this.canvas.style.userSelect = 'none';
        const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;
        // IOS 的“涂鸦”功能拦截点事件。 这样我们可以在快速点击时丢失其中的一些。
        // 使用 IOS 平台的触摸事件来防止它。 有关详细信息，请参阅 https://developer.apple.com/forums/thread/664108。
        if (window.PointerEvent && !isIOS) {
            this._handlePointerEvents();
        }
        else {
            this._handleMouseEvents();
            if ('ontouchstart' in window) {
                this._handleTouchEvents();
            }
        }
        this._resizeCanvas();
        window.addEventListener('resize', this._resizeCanvas.bind(this), false);
    }
    off() {
        // 触摸画布元素时启用平移/缩放
        this.canvas.style.touchAction = 'auto';
        this.canvas.style.msTouchAction = 'auto';
        this.canvas.style.userSelect = 'auto';
        this.canvas.removeEventListener('pointerdown', this._handlePointerStart);
        this.canvas.removeEventListener('pointermove', this._handlePointerMove);
        this.canvas.ownerDocument.removeEventListener('pointerup', this._handlePointerEnd);
        this.canvas.removeEventListener('mousedown', this._handleMouseDown);
        this.canvas.removeEventListener('mousemove', this._handleMouseMove);
        this.canvas.ownerDocument.removeEventListener('mouseup', this._handleMouseUp);
        this.canvas.removeEventListener('touchstart', this._handleTouchStart);
        this.canvas.removeEventListener('touchmove', this._handleTouchMove);
        this.canvas.removeEventListener('touchend', this._handleTouchEnd);
        window.removeEventListener('resize', this._resizeCanvas);
    }
    isEmpty() {
        return this._isEmpty;
    }
    fromData(pointGroups, { clear = true } = {}) {
        if (clear) {
            this.clear();
        }
        this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
        this._data = this._data.concat(pointGroups);
    }
    toData() {
        return this._data;
    }
    toSize() {
        if (this._data) {
            return new Blob(this._data).size;
        }
        else {
            return 0;
        }
    }
    // 考虑像素比调整画布坐标空间，使其在移动设备上看起来清晰。 这也会导致画布被清除。
    _resizeCanvas() {
        // 当缩小到小于 100% 时，出于某种非常奇怪的原因，一些浏览器将 devicePixelRatio 报告为小于 1，然后只有部分画布被清除。
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        // 这部分导致画布被清除
        this.canvas.width = this.canvas.offsetWidth * ratio;
        this.canvas.height = this.canvas.offsetHeight * ratio;
        this._ctx.scale(ratio, ratio);
        // 这个库不监听画布的变化，所以在浏览器自动清除画布后，即使画布看起来是空的，SignaturePad#isEmpty 仍然可能返回 false，
        // 因为这个库的内部数据没有被清除。 为了确保这个库的状态与画布的视觉状态一致，你必须手动清除它。
        this.clear();
    }
    // 事件处理
    _handleMouseDown = (event) => {
        if (event.buttons === 1) {
            this._drawningStroke = true;
            this._strokeBegin(event);
        }
    };
    _handleMouseMove = (event) => {
        if (this._drawningStroke) {
            this._strokeMoveUpdate(event);
        }
    };
    _handleMouseUp = (event) => {
        if (event.buttons === 1 && this._drawningStroke) {
            this._drawningStroke = false;
            this._strokeEnd(event);
        }
    };
    _handleTouchStart = (event) => {
        // 防止滚动。
        if (event.cancelable) {
            event.preventDefault();
        }
        if (event.targetTouches.length === 1) {
            const touch = event.changedTouches[0];
            this._strokeBegin(touch);
        }
    };
    _handleTouchMove = (event) => {
        // 防止滚动。
        if (event.cancelable) {
            event.preventDefault();
        }
        const touch = event.targetTouches[0];
        this._strokeMoveUpdate(touch);
    };
    _handleTouchEnd = (event) => {
        const wasCanvasTouched = event.target === this.canvas;
        if (wasCanvasTouched) {
            if (event.cancelable) {
                event.preventDefault();
            }
            const touch = event.changedTouches[0];
            this._strokeEnd(touch);
        }
    };
    _handlePointerStart = (event) => {
        this._drawningStroke = true;
        event.preventDefault();
        this._strokeBegin(event);
    };
    _handlePointerMove = (event) => {
        if (this._drawningStroke) {
            event.preventDefault();
            this._strokeMoveUpdate(event);
        }
    };
    _handlePointerEnd = (event) => {
        if (this._drawningStroke) {
            event.preventDefault();
            this._drawningStroke = false;
            this._strokeEnd(event);
        }
    };
    // Private methods
    _strokeBegin(event) {
        this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));
        const newPointGroup = {
            dotSize: this.dotSize,
            minWidth: this.minWidth,
            maxWidth: this.maxWidth,
            penColor: this.penColor,
            points: [],
        };
        this._data.push(newPointGroup);
        this._reset();
        this._strokeUpdate(event);
    }
    _strokeUpdate(event) {
        if (this._data.length === 0) {
            // 如果在签名仍在进行时调用了 clear()，或者在启动/更新事件之间存在竞争条件，则可能会发生这种情况
            this._strokeBegin(event);
            return;
        }
        this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));
        const x = event.clientX;
        const y = event.clientY;
        const pressure = event.pressure !== undefined
            ? event.pressure
            : event.force !== undefined
                ? event.force
                : 0;
        const point = this._createPoint(x, y, pressure);
        const lastPointGroup = this._data[this._data.length - 1];
        const lastPoints = lastPointGroup.points;
        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
        const isLastPointTooClose = lastPoint
            ? point.distanceTo(lastPoint) <= this.minDistance
            : false;
        const { penColor, dotSize, minWidth, maxWidth } = lastPointGroup;
        // 如果与上一个太接近，请跳过此点
        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
            const curve = this._addPoint(point);
            if (!lastPoint) {
                this._drawDot(point, {
                    penColor,
                    dotSize,
                    minWidth,
                    maxWidth,
                });
            }
            else if (curve) {
                this._drawCurve(curve, {
                    penColor,
                    dotSize,
                    minWidth,
                    maxWidth,
                });
            }
            lastPoints.push({
                time: point.time,
                x: point.x,
                y: point.y,
                pressure: point.pressure,
            });
        }
        this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));
    }
    _strokeEnd(event) {
        this._strokeUpdate(event);
        this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));
    }
    _handlePointerEvents() {
        this._drawningStroke = false;
        this.canvas.addEventListener('pointerdown', this._handlePointerStart);
        this.canvas.addEventListener('pointermove', this._handlePointerMove);
        this.canvas.ownerDocument.addEventListener('pointerup', this._handlePointerEnd);
    }
    _handleMouseEvents() {
        this._drawningStroke = false;
        this.canvas.addEventListener('mousedown', this._handleMouseDown);
        this.canvas.addEventListener('mousemove', this._handleMouseMove);
        this.canvas.ownerDocument.addEventListener('mouseup', this._handleMouseUp);
    }
    _handleTouchEvents() {
        this.canvas.addEventListener('touchstart', this._handleTouchStart);
        this.canvas.addEventListener('touchmove', this._handleTouchMove);
        this.canvas.addEventListener('touchend', this._handleTouchEnd);
    }
    // 新行开始时调用
    _reset() {
        this._lastPoints = [];
        this._lastVelocity = 0;
        this._lastWidth = (this.minWidth + this.maxWidth) / 2;
        this._ctx.fillStyle = this.penColor;
    }
    _createPoint(x, y, pressure) {
        const rect = this.canvas.getBoundingClientRect();
        return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());
    }
    // 如果有足够的点(即 3)，则将点添加到 _lastPoints 数组并生成一条新曲线
    _addPoint(point) {
        const { _lastPoints } = this;
        _lastPoints.push(point);
        if (_lastPoints.length > 2) {
            // 为了减少初始滞后，通过将第一个点复制到开头，使其使用 3 个点。
            if (_lastPoints.length === 3) {
                _lastPoints.unshift(_lastPoints[0]);
            }
            // _points 数组在这里总是有 4 个点。
            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);
            const curve = Bezier.fromPoints(_lastPoints, widths);
            // 从列表中删除第一个元素，这样任何时候都不会超过4个点。
            _lastPoints.shift();
            return curve;
        }
        return null;
    }
    _calculateCurveWidths(startPoint, endPoint) {
        const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +
            (1 - this.velocityFilterWeight) * this._lastVelocity;
        const newWidth = this._strokeWidth(velocity);
        const widths = {
            end: newWidth,
            start: this._lastWidth,
        };
        this._lastVelocity = velocity;
        this._lastWidth = newWidth;
        return widths;
    }
    _strokeWidth(velocity) {
        return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
    }
    _drawCurveSegment(x, y, width) {
        const ctx = this._ctx;
        ctx.moveTo(x, y);
        ctx.arc(x, y, width, 0, 2 * Math.PI, false);
        this._isEmpty = false;
    }
    _drawCurve(curve, options) {
        const ctx = this._ctx;
        const widthDelta = curve.endWidth - curve.startWidth;
        // '2' 在这里只是一个任意数字。 如果仅使用长度，则曲线段之间存在间隙
        const drawSteps = Math.ceil(curve.length()) * 2;
        ctx.beginPath();
        ctx.fillStyle = options.penColor;
        for (let i = 0; i < drawSteps; i += 1) {
            // 计算此步骤的 Bezier (x, y) 坐标。
            const t = i / drawSteps;
            const tt = t * t;
            const ttt = tt * t;
            const u = 1 - t;
            const uu = u * u;
            const uuu = uu * u;
            let x = uuu * curve.startPoint.x;
            x += 3 * uu * t * curve.control1.x;
            x += 3 * u * tt * curve.control2.x;
            x += ttt * curve.endPoint.x;
            let y = uuu * curve.startPoint.y;
            y += 3 * uu * t * curve.control1.y;
            y += 3 * u * tt * curve.control2.y;
            y += ttt * curve.endPoint.y;
            const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
            this._drawCurveSegment(x, y, width);
        }
        ctx.closePath();
        ctx.fill();
    }
    _drawDot(point, options) {
        const ctx = this._ctx;
        const width = options.dotSize > 0
            ? options.dotSize
            : (options.minWidth + options.maxWidth) / 2;
        ctx.beginPath();
        this._drawCurveSegment(point.x, point.y, width);
        ctx.closePath();
        ctx.fillStyle = options.penColor;
        ctx.fill();
    }
    _fromData(pointGroups, drawCurve, drawDot) {
        for (const group of pointGroups) {
            const { penColor, dotSize, minWidth, maxWidth, points } = group;
            if (points.length > 1) {
                for (let j = 0; j < points.length; j += 1) {
                    const basicPoint = points[j];
                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
                    // 组中的所有点都具有相同的颜色，因此只需在开始时设置 penColor 就足够了。
                    this.penColor = penColor;
                    if (j === 0) {
                        this._reset();
                    }
                    const curve = this._addPoint(point);
                    if (curve) {
                        drawCurve(curve, {
                            penColor,
                            dotSize,
                            minWidth,
                            maxWidth,
                        });
                    }
                }
            }
            else {
                this._reset();
                drawDot(points[0], {
                    penColor,
                    dotSize,
                    minWidth,
                    maxWidth,
                });
            }
        }
    }
    _toSVG() {
        const pointGroups = this._data;
        const ratio = Math.max(window.devicePixelRatio || 1, 1);
        const minX = 0;
        const minY = 0;
        const maxX = this.canvas.width / ratio;
        const maxY = this.canvas.height / ratio;
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', this.canvas.width.toString());
        svg.setAttribute('height', this.canvas.height.toString());
        this._fromData(pointGroups, (curve, { penColor }) => {
            const path = document.createElement('path');
            // 需要检查 NaN 值的曲线，当在画布上绘制不连续的线条时会弹出这些值。 例如。 尖角或中风停止，而不是在不抬起鼠标的情况下继续。
            if (!isNaN(curve.control1.x) &&
                !isNaN(curve.control1.y) &&
                !isNaN(curve.control2.x) &&
                !isNaN(curve.control2.y)) {
                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +
                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +
                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +
                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
                path.setAttribute('d', attr);
                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));
                path.setAttribute('stroke', penColor);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                svg.appendChild(path);
            }
        }, (point, { penColor, dotSize, minWidth, maxWidth }) => {
            const circle = document.createElement('circle');
            const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
            circle.setAttribute('r', size.toString());
            circle.setAttribute('cx', point.x.toString());
            circle.setAttribute('cy', point.y.toString());
            circle.setAttribute('fill', penColor);
            svg.appendChild(circle);
        });
        const prefix = 'data:image/svg+xml;base64,';
        const header = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${this.canvas.width} ${this.canvas.height}" width="${maxX}" height="${maxY}">`;
        let body = svg.innerHTML;
        // 用于 SVGElement 上缺少 innerHTML 属性的 IE hack
        if (body === undefined) {
            const dummy = document.createElement('dummy');
            const nodes = svg.childNodes;
            dummy.innerHTML = '';
            for (let i = 0; i < nodes.length; i += 1) {
                dummy.appendChild(nodes[i].cloneNode(true));
            }
            body = dummy.innerHTML;
        }
        const footer = '</svg>';
        const data = header + body + footer;
        return prefix + window.btoa(data);
    }
}
