class ProgressBars {
    hiding;
    value;
    visible;
    trickle;
    stylesheetElement;
    progressElement;
    static animationDuration = 300;
    trickleInterval;
    constructor() {
        this.hiding = false;
        this.value = 0;
        this.visible = false;
        this.trickle = () => {
            const val = this.value + Math.random() / 100;
            this.setValue(val);
            val >= 0.9 && this.stopTrickling();
        };
        this.stylesheetElement = this.createStylesheetElement();
        this.progressElement = this.createProgressElement();
        this.installStylesheetElement();
    }
    static get defaultCSS() {
        const css = /* css */ `
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: var(--turbo-progress-bg-color, #0076ff);
        z-index: 2147483647;
        transition:
          width ${ProgressBars.animationDuration}ms ease-out,
          opacity ${ProgressBars.animationDuration >> 1}ms ${ProgressBars.animationDuration >> 1}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
        return css.replace(/\s+/g, ' ').trim();
    }
    show() {
        if (!this.visible) {
            this.setValue(0);
            this.visible = true;
            this.installProgressElement();
            this.startTrickling();
        }
    }
    stop() {
        if (this.visible && !this.hiding) {
            this.hiding = true;
            this.fadeProgressElement(() => {
                this.uninstallProgressElement();
                this.stopTrickling();
                this.visible = false;
                this.hiding = false;
            });
        }
    }
    hide() {
        if (this.visible && !this.hiding) {
            this.setValue(1);
            this.hiding = true;
            this.fadeProgressElement(() => {
                this.uninstallProgressElement();
                this.stopTrickling();
                this.visible = false;
                this.hiding = false;
            });
        }
    }
    setValue(value) {
        this.value = value;
        this.refresh();
    }
    installStylesheetElement() {
        document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
        this.progressElement.style.cssText = 'width:0;opacity:1;';
        document.body.insertBefore(this.progressElement, document.body.firstChild);
        this.refresh();
    }
    fadeProgressElement(callback) {
        this.progressElement.style.opacity = '0';
        setTimeout(callback, ProgressBars.animationDuration * 1.5);
    }
    uninstallProgressElement() {
        if (this.progressElement.parentNode) {
            document.body.removeChild(this.progressElement);
        }
    }
    startTrickling() {
        if (!this.trickleInterval) {
            this.trickleInterval = window.setInterval(this.trickle, ProgressBars.animationDuration);
        }
    }
    stopTrickling() {
        window.clearInterval(this.trickleInterval);
        delete this.trickleInterval;
    }
    refresh() {
        requestAnimationFrame(() => {
            this.progressElement.style.width = `${10 + this.value * 90}%`;
        });
    }
    createStylesheetElement() {
        const element = document.createElement('style');
        element.setAttribute('type', 'text/css');
        element.textContent = ProgressBars.defaultCSS;
        return element;
    }
    createProgressElement() {
        const element = document.createElement('div');
        element.className = 'turbo-progress-bar';
        return element;
    }
}
export default new ProgressBars();
