import ProgressBars from "./progress-bar";
class ProxyClientRequest {
    static _fetch;
    static _xmlopen = XMLHttpRequest.prototype.open;
    constructor(win) {
        ProxyClientRequest._fetch = win.fetch.bind(win);
        win.fetch = this.proxyFetch.bind(win);
        this.proxyXMLHttpRequest();
        this.proxyDocument();
    }
    /**
     * 监听 DOM 加载情况
     */
    proxyDocument() {
        ProgressBars.show();
        document.addEventListener('readystatechange', ev => {
            if (!ev.target) {
                return;
            }
            const target = ev.target;
            if (target.readyState === 'complete') {
                ProgressBars.hide();
            }
        }, false);
    }
    /**
     * 监听 XMLHttpRequest 相关事件
     */
    proxyXMLHttpRequest() {
        // 需要在请求调用 open() 之前添加事件监听, 否则 progress 事件将不会被触发
        // 同时 progress 事件在使用 file: 协议的情况下是无效的
        XMLHttpRequest.prototype.open = function (method, url, async = true, username, password) {
            // ProgressBars.show();
            ProxyClientRequest._xmlopen.call(this, method, url, async, username, password);
            // 使用 loadend 事件可以监测到所有的三种加载结束条件(abort, load, error)
            this.addEventListener('loadstart', () => ProgressBars.show(), false);
            this.addEventListener('abort', () => ProgressBars.stop(), false); // 请求被取消
            this.addEventListener('error', () => ProgressBars.stop(), false); // 请求出错
            this.addEventListener('timeout', () => ProgressBars.stop(), false); // 请求超时
            this.addEventListener('load', () => ProgressBars.hide(), false); // 请求成功
        };
    }
    /**
     * 代理 Fetch
     *
     * @param input RequestInfo
     * @param init RequestInit
     * @returns Promise<Response>
     */
    async proxyFetch(input, init) {
        ProgressBars.show();
        return ProxyClientRequest._fetch(input, init)
            .then(ok => (ProgressBars.hide(), ok))
            .catch(err => (ProgressBars.stop(), err));
    }
}
new ProxyClientRequest(window);
