import TemplateError from './adapter/error';
import esTokenizer from './es-tokenizer';
import tplTokenizer from './tpl-tokenizer';
/** 传递给模板的数据引用 */
const DATA = `$data`;
/** 外部导入的所有全局变量引用 */
const IMPORTS = `$imports`;
/**  $imports.$escape */
const ESCAPE = `$escape`;
/**  $imports.$each */
const EACH = `$each`;
/** 文本输出函数 */
const PRINT = `print`;
/** 包含子模板函数 */
const INCLUDE = `include`;
/** 字符串拼接变量 */
const OUT = `$$out`;
/** 运行时逐行调试记录变量 [line, start, source] */
const LINE = `$$line`;
/** 编译设置变量 */
const OPTIONS = `$$options`;
const has = (object, key) => Object.hasOwnProperty.call(object, key);
const stringify = JSON.stringify;
class Compiler {
    options;
    stacks;
    context;
    scripts;
    CONTEXT_MAP;
    ignore;
    internal;
    dependencies;
    source;
    static CONSTS;
    /**
     * 模板编译器
     */
    constructor(options) {
        let source = options.source || '';
        // 编译选项
        this.options = options;
        // 所有语句堆栈
        this.stacks = [];
        // 运行时注入的上下文
        this.context = [];
        // 模板语句编译后的代码
        this.scripts = [];
        // context map
        this.CONTEXT_MAP = {};
        // 忽略的变量名单
        this.ignore = [DATA, IMPORTS, OPTIONS, ...(options.ignore || [])];
        // 按需编译到模板渲染函数的内置变量
        this.internal = {
            [OUT]: `''`,
            [LINE]: `[0,0]`,
            [PRINT]: `function(){var s=''.concat.apply('',arguments);${OUT}+=s;return s}`,
            [INCLUDE]: `async function(src,data){var s=await ${OPTIONS}.include(src,data||${DATA},${OPTIONS});${OUT}+=s;return s}`,
        };
        // 内置函数依赖关系声明
        this.dependencies = {
            [PRINT]: [OUT],
            [INCLUDE]: [OUT, DATA, OPTIONS,],
        };
        this.importContext(OUT);
        if (options.recompile) {
            this.importContext(LINE);
        }
        this.source = source;
        this.getTplTokens(source, options.rules, this).forEach((tokens) => {
            if (tokens.type === tplTokenizer.TYPE_STRING) {
                this.parseString(tokens);
            }
            else {
                this.parseExpression(tokens);
            }
        });
    }
    /**
     * 将模板代码转换成 tplToken 数组
     */
    getTplTokens(source, rules, context) {
        return tplTokenizer(source, rules, context);
    }
    /**
     * 将模板表达式转换成 esToken 数组
     */
    getEsTokens(source) {
        return esTokenizer(source);
    }
    /**
     * 获取变量列表
     */
    getVariables(esTokens) {
        let ignore = false;
        return esTokens
            .filter((esToken) => {
            return esToken.type !== `whitespace` && esToken.type !== `comment`;
        })
            .filter((esToken) => {
            if (esToken.type === `name` && !ignore) {
                return true;
            }
            ignore = esToken.type === `punctuator` && esToken.value === `.`;
            return false;
        })
            .map((tooken) => tooken.value);
    }
    /**
     * 导入模板上下文
     */
    importContext(name) {
        let value = ``;
        const internal = this.internal;
        const dependencies = this.dependencies;
        const ignore = this.ignore;
        const context = this.context;
        const options = this.options;
        const imports = options.imports || {};
        const contextMap = this.CONTEXT_MAP;
        if (!has(contextMap, name) && ignore.indexOf(name) === -1) {
            if (has(internal, name)) {
                value = internal[name];
                if (has(dependencies, name)) {
                    dependencies[name].forEach(name => this.importContext(name));
                }
                // imports 继承了 Global，但是继承的属性不分配到顶级变量中，避免占用了模板内部的变量名称
            }
            else if (name === ESCAPE || name === EACH || has(imports, name)) {
                value = `${IMPORTS}.${name}`;
            }
            else {
                value = `${DATA}.${name}`;
            }
            contextMap[name] = value;
            context.push({
                name,
                value
            });
        }
    }
    /**
     * 解析字符串（HTML）直接输出语句
     */
    parseString(tplToken) {
        let source = tplToken.value;
        if (!source) {
            return;
        }
        const code = `${OUT}+=${stringify(source)}`;
        this.scripts.push({
            source,
            tplToken,
            code
        });
    }
    /**
     * 解析逻辑表达式语句
     */
    parseExpression(tplToken) {
        const source = tplToken.value;
        const script = tplToken.script;
        const output = script.output;
        const escape = this.options.escape;
        let code = script.code;
        if (output) {
            if (escape === false || output === tplTokenizer.TYPE_RAW) {
                code = `${OUT}+=${script.code}`;
            }
            else {
                code = `${OUT}+=${ESCAPE}(${script.code})`;
            }
        }
        const esToken = this.getEsTokens(code);
        this.getVariables(esToken).forEach((name) => this.importContext(name));
        this.scripts.push({
            source,
            tplToken,
            code
        });
    }
    /**
     * 检查解析后的模板语句是否存在语法错误
     */
    checkExpression(script) {
        // 没有闭合的块级模板语句规则
        // 基于正则规则来补全语法不能保证 100% 准确，
        // 但是在绝大多数情况下足以满足辅助开发调试的需要
        const rules = [
            // <% } %>
            // <% }else{ %>
            // <% }else if(a){ %>
            [/^\s*}[\w\W]*?{?[\s;]*$/, ''],
            // <% fn(c,function(a,b){ %>
            // <% fn(c, a=>{ %>
            // <% fn(c,(a,b)=>{ %>
            [/(^[\w\W]*?\([\w\W]*?(?:=>|\([\w\W]*?\))\s*{[\s;]*$)/, '$1})'],
            // <% if(a){ %>
            // <% for(var i in d){ %>
            [/(^[\w\W]*?\([\w\W]*?\)\s*{[\s;]*$)/, '$1}']
        ];
        let index = 0;
        while (index < rules.length) {
            if (rules[index][0].test(script)) {
                script = script.replace(...rules[index]);
                break;
            }
            index++;
        }
        try {
            new Function(script);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * 编译
     */
    build(id_or_url) {
        const options = this.options;
        const context = this.context;
        const scripts = this.scripts;
        const stacks = this.stacks;
        const source = this.source;
        const imports = options.imports;
        const mappings = [];
        let offsetLine = 0;
        // Create SourceMap: mapping
        const mapping = (code, { line, start }) => {
            const node = {
                generated: {
                    line: stacks.length + offsetLine + 1,
                    column: 1
                },
                original: {
                    line: line + 1,
                    column: start + 1
                }
            };
            offsetLine += code.split(/\n/).length - 1;
            return node;
        };
        // Trim code
        const trim = (code) => {
            return code.replace(/^[\t ]+|[\t ]$/g, '');
        };
        stacks.push(`async function(${DATA}){`);
        stacks.push(`'use strict'`);
        if (options.debug) {
            const css1 = 'background-color:green;padding:2px;border-radius:2px 0 0 2px', css2 = 'background-color:gray;padding:2px;border-radius:0 2px 2px 0';
            stacks.push(`console.info('%cdebug%cmode','${css1}','${css2}','This mode is used to debug templates ===>','${id_or_url}')`);
        }
        stacks.push(`${DATA}=${DATA}||{}`);
        stacks.push(`var ${context.map(({ name, value }) => `${name}=${value}`).join(`,`)}`);
        if (options.recompile) {
            stacks.push(`try{`);
            scripts.forEach(script => {
                if (script.tplToken.type === tplTokenizer.TYPE_EXPRESSION) {
                    stacks.push(`${LINE}=[${[script.tplToken.line, script.tplToken.start].join(',')}]`);
                }
                mappings.push(mapping(script.code, script.tplToken));
                stacks.push(trim(script.code));
            });
            stacks.push(`}catch(error){`);
            stacks.push('throw {' +
                [
                    `name:'RuntimeError'`,
                    `path:${stringify(id_or_url)}`,
                    `message:error.message`,
                    `line:${LINE}[0]+1`,
                    `column:${LINE}[1]+1`,
                    `source:${stringify(source)}`,
                    `stack:error.stack`
                ].join(`,`) +
                '}');
            stacks.push(`}`);
        }
        else {
            scripts.forEach(script => {
                mappings.push(mapping(script.code, script.tplToken));
                stacks.push(trim(script.code));
            });
        }
        stacks.push(`return ${OUT}`);
        stacks.push(`}`);
        const renderCode = stacks.join(`\n`);
        try {
            const result = new Function(IMPORTS, OPTIONS, `return ${renderCode}`)(imports, options);
            result.mappings = mappings;
            result.sourcesContent = [source];
            return result;
        }
        catch (error) {
            let index = 0;
            let line = 0;
            let start = 0;
            let generated;
            while (index < scripts.length) {
                const current = scripts[index];
                if (!this.checkExpression(current.code)) {
                    line = current.tplToken.line;
                    start = current.tplToken.start;
                    generated = current.code;
                    break;
                }
                index++;
            }
            throw new TemplateError({
                name: `CompileError`,
                path: id_or_url,
                message: error.message,
                line: line + 1,
                column: start + 1,
                source,
                generated,
                stack: error.stack
            });
        }
    }
}
/**
 * 模板内置常量
 */
Compiler.CONSTS = {
    DATA,
    IMPORTS,
    PRINT,
    INCLUDE,
    OPTIONS,
    OUT,
    ESCAPE,
    EACH
};
export default Compiler;
